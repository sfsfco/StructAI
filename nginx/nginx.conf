# ═══════════════════════════════════════════════════════════════════════
#  Nginx – Reverse proxy & load balancer for StructAI API
# ═══════════════════════════════════════════════════════════════════════
#
#  Docker Compose DNS resolves "api" to all container IPs when scaled,
#  so the upstream block automatically load-balances across replicas.
#
#  Usage:
#    docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --scale api=3
# ═══════════════════════════════════════════════════════════════════════

worker_processes auto;
worker_rlimit_nofile 65535;

events {
    worker_connections 4096;
    multi_accept on;
    use epoll;
}

http {
    # ── Basic settings ───────────────────────────────────────────────
    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    keepalive_requests  1000;
    types_hash_max_size 2048;

    # ── Logging ──────────────────────────────────────────────────────
    log_format structured escape=json
        '{'
            '"time":"$time_iso8601",'
            '"remote_addr":"$remote_addr",'
            '"method":"$request_method",'
            '"uri":"$request_uri",'
            '"status":$status,'
            '"body_bytes_sent":$body_bytes_sent,'
            '"request_time":$request_time,'
            '"upstream_response_time":"$upstream_response_time",'
            '"upstream_addr":"$upstream_addr",'
            '"http_user_agent":"$http_user_agent",'
            '"correlation_id":"$upstream_http_x_correlation_id"'
        '}';

    access_log /var/log/nginx/access.log structured;
    error_log  /var/log/nginx/error.log warn;

    # ── Gzip compression ────────────────────────────────────────────
    gzip            on;
    gzip_vary       on;
    gzip_min_length 256;
    gzip_comp_level 4;
    gzip_types
        application/json
        application/javascript
        text/plain
        text/css;

    # ── Rate limiting zones ──────────────────────────────────────────
    # 10 req/s per IP for general API traffic
    limit_req_zone $binary_remote_addr zone=api_general:10m rate=10r/s;
    # 2 req/s per IP for extraction (expensive LLM calls)
    limit_req_zone $binary_remote_addr zone=api_extract:10m rate=2r/s;

    # ── Upstream: API replicas ───────────────────────────────────────
    upstream structai_api {
        # Least-connections balancing — sends requests to the replica
        # with the fewest active connections (best for varied latencies).
        least_conn;

        # Docker Compose DNS resolves "api" to all container IPs.
        server api:8000 max_fails=3 fail_timeout=30s;

        # Keep persistent connections to upstreams for performance.
        keepalive 32;
    }

    # ── Server block ─────────────────────────────────────────────────
    server {
        listen 80;
        server_name _;

        # Max request body size (documents can be large)
        client_max_body_size 50m;

        # ── Proxy defaults ───────────────────────────────────────────
        proxy_http_version 1.1;
        proxy_set_header   Host              $host;
        proxy_set_header   X-Real-IP         $remote_addr;
        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_set_header   Connection        "";

        # Propagate correlation ID if the client sends one
        proxy_set_header   X-Correlation-ID  $http_x_correlation_id;

        # Timeouts — extraction can take a while (LLM calls)
        proxy_connect_timeout 10s;
        proxy_read_timeout    120s;
        proxy_send_timeout    30s;

        # ── Health endpoint (no rate limit) ──────────────────────────
        location /api/v1/health {
            proxy_pass http://structai_api;
        }

        location /api/v1/ready {
            proxy_pass http://structai_api;
        }

        # ── Metrics (restrict to internal / monitoring) ──────────────
        location /metrics {
            # In production, restrict to Prometheus scraper IPs:
            # allow 10.0.0.0/8;
            # deny all;
            proxy_pass http://structai_api;
        }

        # ── Extraction endpoint (stricter rate limit) ────────────────
        location /api/v1/extract {
            limit_req zone=api_extract burst=5 nodelay;
            limit_req_status 429;

            proxy_pass http://structai_api;
        }

        # ── All other API routes ─────────────────────────────────────
        location /api/ {
            limit_req zone=api_general burst=20 nodelay;
            limit_req_status 429;

            proxy_pass http://structai_api;
        }

        # ── Default: 404 ─────────────────────────────────────────────
        location / {
            return 404 '{"detail":"Not Found"}';
            default_type application/json;
        }

        # ── Custom error pages ───────────────────────────────────────
        error_page 502 503 504 /50x.json;
        location = /50x.json {
            internal;
            default_type application/json;
            return 503 '{"detail":"Service temporarily unavailable. Please retry.","retry_after":10}';
        }
    }
}
